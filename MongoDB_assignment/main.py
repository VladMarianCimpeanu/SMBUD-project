import sys
sys.path.insert(0, '../')
import random
import string
import datetime
from random_italian_things import RandomItalianPerson, RandomItalianHouse, random_amenity
from random_italian_things.utils import date_generator as dg, date_facilities
from pymongo import MongoClient
from pprint import pprint
import pandas as pd
import numpy as np




class MongoPopulate:
    def __init__(self, connection_string):
        self.client = MongoClient(connection_string, tls=True, tlsAllowInvalidCertificates=True)
        self.db = self.client.SMBUD
        self.vaccines = None
        self.doctors = []
        self.nurses = []
        self.places = []
        self.recovery_people = []
        self.people = []
        self.UCI = []

    def get_new_uci(self) -> str:
        while True:
            uci = '01ITA797891BBF264E88B9BB8E' + ''.join(random.choices(string.digits, k=6)) + random.choice(
                string.ascii_uppercase) + random.choice(string.digits) + random.choice(string.ascii_uppercase)
            if uci not in self.UCI:
                self.UCI.append(uci)
                return uci

    def create_people(self, num_doc=25, num_nurse=50, num_people=100, num_rec_people=5):
        for i in range(0, num_doc):
            random_italian_person = RandomItalianPerson()
            self.doctors.append(self.create_sanitary_operator('Doctor', random_italian_person))
        for i in range(0, num_nurse):
            random_italian_person = RandomItalianPerson()
            self.nurses.append(self.create_sanitary_operator('Nurse', random_italian_person))
        for i in range(0, num_people):
            random_italian_person = RandomItalianPerson()
            self.people.append(self.create_person(random_italian_person))
        for i in range(0, num_rec_people):
            random_italian_person = RandomItalianPerson()
            self.recovery_people.append(self.create_person(random_italian_person))

    @staticmethod
    def create_sanitary_operator(sanitary_type, random_italian_person):
        sanitary_operator = {
            "type": sanitary_type,
            "name": random_italian_person.name,
            "surname": random_italian_person.surname,
            "tax_code": random_italian_person.tax_code,
            "contact": random_italian_person.phone_number
        }
        return sanitary_operator

    def create_person(self, random_italian_person):
        person = {
            "name": random_italian_person.name,
            "surname": random_italian_person.surname,
            "tax code": random_italian_person.tax_code,
            "dob": random_italian_person.birthdate,
            "emergency name": RandomItalianPerson().name + " " + RandomItalianPerson().surname,
            "emergency contact": random_italian_person.phone_number
        }
        return person

    def create_places(self):
        '''self.db.places.drop()  # drop places before running
        collection = self.db.places  # alias of collection into the function'''
        places_df = pd.read_csv('datasets/locations.csv')  # read csv with places
        places = []  # initialize places as list
        for index, row in places_df.iterrows():
            place = {
                "building_name": row.building_name,
                "type": row.type,
                "region": row.region,
                "gps" : str(random.uniform(-90, 90)) + "," + str(random.uniform(-180, 180))
            }
            places.append(place)  # append each place in form of dict in places list
        self.places=places

    """ For the vaccinations all the irrelevant information can be randomly generated by this function.
        For sake of simplicity the sn number will be the same for all the certifications, even though in 
        reality it may changes due to mixed vaccinations."""

    def create_vaccination(self, doctor_document: dict, nurse_document: dict, vaccination_place: dict,
                           vaccination_date: datetime, vaccine_name: str, vaccine_dose: int) -> dict:
        if self.vaccines is None:
            self.vaccines = pd.read_csv("datasets/vaccines.csv")
        vaccination_document = {
            "revoked": False,  # for simplicity sake all the vaccines will be legally valid by default
            "name": vaccine_name,
            "brand": self.vaccines.loc[self.vaccines["name" == vaccine_name], "brand"][0],
            "type": self.vaccines.loc[self.vaccines["name" == vaccine_name], "type"][0],
            "lot": random.randint(200000, 300000),
            "sn": int(self.vaccines.loc[self.vaccines["name" == vaccine_name], "sn"][0]),
            "dn": vaccine_dose,
            "issuer": "Italian Ministry of Health",
            "nurse": nurse_document,
            "doctor": doctor_document,
            "place": vaccination_place,
            "date": vaccination_date,
            "expiration date": vaccination_date + datetime.timedelta(days=int(self.vaccines
                                                                              .loc[
                                                                                  self.vaccines["name"] == vaccine_name,
                                                                                  "validity" + str(vaccine_dose)]))
        }
        return vaccination_document

    """Function used to generate recovery certificates"""

    def create_recovery(self,days_duration=180):
        print("Creation of recovery certificates in progress...")
        self.db.recovery.drop()  # recovery cleaning from db
        collection = self.db.recovery
        date = datetime.datetime.strptime(dg.DateGenerator().random_datetimes_or_dates('date').tolist()[0],
                                          '%Y-%m-%d')
        valid_date = date + datetime.timedelta(days=random.randrange(10, 21))
        # the following while checks that the uci is unique and that it is not already present in the db
        uci = self.get_new_uci()
        recovery = {
            "revoked": False,
            "date": date,
            "valid from": valid_date,
            "expiration date": valid_date + datetime.timedelta(days=days_duration),
            "uci swab": uci,
            "issuer": "Italian Ministry of Health"
        }
        return recovery

    def create_test(self, revoked, datetime_attribute, test_type, result, place_document, sanitary_operator_document):
        test_document = {
            "revoked": revoked,
            "datetime": datetime_attribute,
            "type": test_type,
            "issuer": "Italian Ministry of Health",
            "result": result,
            "place": place_document,
            "sanitary operator": sanitary_operator_document,
        }
        if result == "Negative":
            if test_type == 'Rapid':
                expiration_date = datetime_attribute + datetime.timedelta(hours=48)
            else:
                expiration_date = datetime_attribute + datetime.timedelta(hours=72)
            test_document['expiration date'] = expiration_date
        return test_document

    def create_random_test(self, prob_positive = 0):
        revoked = False
        datetime_attribute = datetime.datetime.strptime(
            dg.DateGenerator().random_datetimes_or_dates('datetime').tolist()[0], "%Y-%m-%d %H:%M:%S")
        test_type = random.choices(['Rapid', 'Molecular'], [0.95, 0.05])[0]
        result = random.choices(['Negative', 'Positive'], [1-prob_positive, prob_positive])[0]
        test = self.create_test(revoked=revoked,
                                datetime_attribute=datetime_attribute,
                                test_type=test_type,
                                result=result,
                                place_document=random.choices(self.places)[0],
                                sanitary_operator_document=random.choice(self.nurses)
                                )
        return test

    def create_certificate(self, person: dict, uci, cert_type, cert_type_info: dict):
        certificate = {
            "name": person['name'],
            "surname": person['surname'],
            "dob": person['dob'],
            "tax code": person['tax code'],
            "emergency contact": person['emergency contact'],
            "emergency name": person['emergency name'],
            "uci": uci,
            cert_type: cert_type_info
        }
        return certificate

    def create_random_certificate(self, cert_type, collection):
        person = random.choice(self.people)
        uci = self.get_new_uci()
        if cert_type == 'Recovery':
            recovery_dict = self.create_recovery()
            certificate_recovery = self.create_certificate(person, uci, 'Recovery', recovery_dict)
            collection.insert_one(certificate_recovery)

            test_1 = self.create_test(revoked=False,
                                      datetime_attribute=recovery_dict['date'],
                                      test_type='Molecular',
                                      result='Positive',
                                      place_document=random.choice(self.places),
                                      sanitary_operator_document=random.choice(self.nurses))
            certificate_test_1 = self.create_certificate(person,
                                                         self.get_new_uci(),
                                                         'Test',
                                                         test_1)
            collection.insert_one(certificate_test_1)

            test_2 = self.create_test(revoked=False,
                                      datetime_attribute=recovery_dict['valid from'],
                                      test_type='Molecular',
                                      result='Negative',
                                      place_document=random.choice(self.places),
                                      sanitary_operator_document=random.choice(self.nurses))
            certificate_test_2 = self.create_certificate(person,
                                                         recovery_dict['uci swab'],
                                                         'Test',
                                                         test_2)
            collection.insert_one(certificate_test_2)
            pass
        elif cert_type == 'Test':
            certificate = self.create_certificate(person, uci, 'Test', self.create_random_test())
            collection.insert_one(certificate)
        elif cert_type == 'Vaccination':
            pass
        else:
            print('Error')
        return

    def create_certificates(self, num_rec, num_test, num_vacc):
        print("Creation of certificates in progress...")
        self.db.certificates.drop()  # recovery cleaning from db
        collection = self.db.certificates
        certificates = []
        for i in range(0, num_rec):
            self.create_random_certificate('Recovery', collection)
        for i in range(0, num_test):
            self.create_random_certificate('Test', collection)
        for i in range(0, num_vacc):
            self.create_random_certificate('Vaccination', collection)
        return


if __name__ == "__main__":
    with open("connection_string.txt", "r") as connection_string_reader:
        connection_string = connection_string_reader.readline().split()[0]
        mongo_populate = MongoPopulate(connection_string)
        # places contains the list of all the places
        mongo_populate.create_places()
        mongo_populate.create_people()
        # create_recovery: the first parameter is the amount of certificates that will be created
        # the second one is the duration - in days- of the certification
        # mongo_populate.create_recovery(10, 180)
        mongo_populate.create_certificates(3, 20, 0)
